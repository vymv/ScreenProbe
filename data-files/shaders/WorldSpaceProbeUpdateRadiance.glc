#version 430 // -*- c++ -*-
#extension GL_ARB_texture_query_lod : enable
#extension GL_ARB_compute_variable_group_size : enable
layout( local_size_variable ) in;
#include <g3dmath.glsl>
#include <Texture/Texture.glsl>
//
//#include "GridHelpers.glsl"
#include <octahedral.glsl>

#define RadianceProbeResolution 16
#define AtlasResolutionInProbe 128
#define AtlasResolution AtlasResolutionInProbe * RadianceProbeResolution
#define RAY_UNUSED 0xFFFFFFFF
#define INVALID_PROBE_INDEX 0xFFFFFFFF

layout(std430, binding=0) buffer rayMarker{ uvec2 RayMarker[AtlasResolutionInProbe][AtlasResolutionInProbe];};

uniform Texture2D                 rayDirections;
uniform Texture2D                 rayHitLocations;
uniform Texture2D                 rayHitRadiance;
uniform Texture2D                 rayHitNormals;
uniform Texture2D                 rayOrigins;

layout(rgba32f) uniform image2D RadianceCache;
layout(rgba32f) uniform image2D RadianceCacheDepth;

uniform int                       probeSideLength;
uniform float                     maxDistance;
uniform float                     energyConservation;

//uniform IrradianceField           irradianceField;

uniform float                     hysteresis;
uniform float                     depthSharpness;
const   float                     epsilon = 1e-6;

shared float sum_weights[RadianceProbeResolution * RadianceProbeResolution];
shared vec3 sum_radiance[RadianceProbeResolution * RadianceProbeResolution];
shared float sum_depth_weights[RadianceProbeResolution * RadianceProbeResolution];
shared vec3 sum_depth[RadianceProbeResolution * RadianceProbeResolution];
shared int validRayAllocator = 0;
shared int validDepthRayAllocator = 0;

// Compute normalized oct coord, mapping top left of top left pixel to (-1,-1) 该纹素在对应的Probe的一小块Texture中，处于什么位置，用以计算对应的direction
vec2 normalizedOctCoord(ivec2 rayAtlasCoord) {

    vec2 rayLocalCoord = ivec2(rayAtlasCoord.x % RadianceProbeResolution, rayAtlasCoord.y % RadianceProbeResolution);
    // Add back the half pixel to get pixel center normalized coordinates
    return (rayLocalCoord + vec2(0.5f))*(2.0f / float(RadianceProbeResolution)) - vec2(1.0f, 1.0f);
}

void main() {

    // 更新的纹理是IradianceProbe
    ivec2 atlasCoord = ivec2(gl_WorkGroupID.xy);

    ivec2 ProbeCoord = atlasCoord / RadianceProbeResolution;

    uvec2 mark = RayMarker[ProbeCoord.y][ProbeCoord.x];

    uint probeIndex = mark.x ;

    if(probeIndex != INVALID_PROBE_INDEX){
        ivec2 C = ivec2(gl_LocalInvocationID.xy) + ProbeCoord * RadianceProbeResolution;
        Vector3 rayDirection    = sampleTextureFetch(rayDirections, C, 0).xyz;
        Color3  rayHitRadiance  = sampleTextureFetch(rayHitRadiance, C, 0).xyz * energyConservation;
		Point3  rayHitLocation  = sampleTextureFetch(rayHitLocations, C, 0).xyz;

        Point3 probeLocation = sampleTextureFetch(rayOrigins, C, 0).xyz;
        // Will be zero on a miss
		Vector3 rayHitNormal    = sampleTextureFetch(rayHitNormals, C, 0).xyz;
        rayHitLocation += rayHitNormal * 0.01f;
        float rayProbeDistance = min(maxDistance, length(probeLocation - rayHitLocation));
        if (dot(rayHitNormal, rayHitNormal) < epsilon) {
            rayProbeDistance = maxDistance;
        }

        vec3 texelDirection = octDecode(normalizedOctCoord(atlasCoord));

        float weight = max(0.0, dot(texelDirection, rayDirection));
        float depth_weight = pow(max(0.0, dot(texelDirection, rayDirection)), depthSharpness);
        if(weight > epsilon){
            int index = atomicAdd(validRayAllocator, 1);
            sum_weights[index] = weight;
            sum_radiance[index] = vec3(rayHitRadiance) * weight;
           
        }
        if(depth_weight > epsilon){
            int index = atomicAdd(validDepthRayAllocator, 1);
            sum_depth_weights[index] = depth_weight;
            sum_depth[index] = vec3(rayProbeDistance * weight, square(rayProbeDistance) * weight, 0.0) * weight;
        }
    }
    barrier();
    if(all(equal(gl_LocalInvocationID, uvec3(0,0,0)))){
        vec3 radiance;
        float weightSum;
        for(int i = 0; i < int(validRayAllocator); i++){
            
            radiance += sum_radiance[i];
            weightSum += sum_weights[i];
        }
        if(weightSum > weightSum)
        imageStore(RadianceCache, atlasCoord, vec4(radiance / max(weightSum, epsilon), 0));

        vec3 depthResult;
        float depthWeightSum;
        for(int i = 0; i < int(validDepthRayAllocator); i++){
            depthResult += sum_depth[i];
            depthWeightSum += sum_depth_weights[i];
        }
        if(depthWeightSum > epsilon)
        imageStore(RadianceCacheDepth, atlasCoord, vec4(depthResult / max(depthWeightSum, epsilon), 0));

    }

}
