#version 430
#extension GL_ARB_texture_query_lod : enable
#extension GL_ARB_compute_variable_group_size : enable
//#include "WorldSpaceProbe_Common.pix"
#define USED_PROBE_INDEX 0xFFFFFFFE
#define RADIANCE_PROBE_MAX_CLIPMAPS 4
#define INVALID_PROBE_INDEX 0xFFFFFFFF
#define PROBE_FRAME_INDEX_NEVER_TRACED 0
#define MAX_UPDATE_FREQUENCY 7.0f

#define PRIORITY_HISTOGRAM_SIZE 128


layout( local_size_variable ) in;


layout(std430, binding=0) buffer radianceProbeCoordToWorldPosition {vec4 RadianceProbeCoordToWorldPosition[];};


layout(r32i) uniform iimage2D ProbeFreeListAllocator;
layout(r32i) uniform iimage2D ProbeAllocator;


layout(r32ui) uniform uimage3D RadianceProbeIndirectionTexture;
layout(r32ui) uniform uimage2D ProbeLastUsedFrame;
layout(r32ui) uniform uimage2D ProbeLastTracedFrame;
layout(r32ui) uniform uimage2D ProbeFreeList;
layout(r32ui) uniform uimage2D PriorityHistogram;

uniform uint FrameNumber;

uniform int RadianceProbeClipmapResolution;

uniform int MaxProbeCount;
uniform vec3 WorldCameraOrigin;
uniform float FirstClipmapWorldExtentRcp;
uniform int NumProbesToTraceBudget;

uniform float DownsampleDistanceFromCameraSq;
uniform float SupersampleDistanceFromCameraSq;

uint GetPriorityBucketIndex(uint LastTracedFrameIndex, uint LastUsedFrameIndex, vec3 ProbeWorldPosition)
{
	// [1;N]
	uint FramesBetweenTracedAndUsed = LastUsedFrameIndex - LastTracedFrameIndex;

	uint BucketIndex = 0;

	if (LastTracedFrameIndex == PROBE_FRAME_INDEX_NEVER_TRACED)
	{
		// Special case for probes which were created this frame. Places those in the most important bucket 0.
		BucketIndex = 0;
	}
	else
	{
		// [0;MAX_UPDATE_FREQUENCY]
		float Frequency = 1.0f;
		{
			vec3 CameraVector = WorldCameraOrigin - ProbeWorldPosition;
			const float DistanceFromViewer = sqrt(dot(CameraVector, CameraVector));
			Frequency = MAX_UPDATE_FREQUENCY - clamp(DistanceFromViewer * FirstClipmapWorldExtentRcp, 0.0f, MAX_UPDATE_FREQUENCY);
		}

		// [1;N]
		float UpdateImportance = FramesBetweenTracedAndUsed * (Frequency + 1.0f);

		// Normalize histogram based on the expected range
		float HistogramScale = (PRIORITY_HISTOGRAM_SIZE * NumProbesToTraceBudget) / (MaxProbeCount * (MAX_UPDATE_FREQUENCY + 1.0f));

		// Remap from [1;N] to log2([N;1])
		BucketIndex = uint(PRIORITY_HISTOGRAM_SIZE - 1 - clamp((UpdateImportance - 1.0f) * HistogramScale, 0, PRIORITY_HISTOGRAM_SIZE - 2));
	}

	return BucketIndex;
}


uint GetProbeTraceCostBudget()
{
	return NumProbesToTraceBudget * 4;
}

uint GetProbeTraceCost(vec3 ProbeWorldPosition)
{
	vec3 CameraVector = WorldCameraOrigin - ProbeWorldPosition;
	float DistanceFromCameraSq = dot(CameraVector, CameraVector);

	if (DistanceFromCameraSq < SupersampleDistanceFromCameraSq)
	{
		return 16;
	}

	if (DistanceFromCameraSq < DownsampleDistanceFromCameraSq)
	{
		return 4;
	}

	return 1;
}


void AllocateUsedProbesCS()
{
	uint ClipmapIndex = gl_GlobalInvocationID.x / RadianceProbeClipmapResolution;
	ivec3 ProbeCoord = ivec3(gl_GlobalInvocationID.x - ClipmapIndex * RadianceProbeClipmapResolution, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z);

	if (ClipmapIndex < RADIANCE_PROBE_MAX_CLIPMAPS && all(lessThan(ProbeCoord, ivec3(RadianceProbeClipmapResolution))))
	{
		uint ProbeUsedMarker = imageLoad(RadianceProbeIndirectionTexture, ivec3(gl_GlobalInvocationID)).r;
		vec3 ProbeWorldPosition = ProbeCoord * RadianceProbeCoordToWorldPosition[ClipmapIndex].w + RadianceProbeCoordToWorldPosition[ClipmapIndex].xyz;;

		if (ProbeUsedMarker != INVALID_PROBE_INDEX)
		{
			uint ProbeIndex = INVALID_PROBE_INDEX;
			uint LastTracedFrameIndex = 0;
			uint LastUsedFrameIndex = 0;

			if (ProbeUsedMarker == USED_PROBE_INDEX)
			{
				// first allocate from freelist, if empty, delegate to allocator
				if(FrameNumber > 1){
					int NumFree;
					NumFree = imageAtomicAdd(ProbeFreeListAllocator,ivec2(0,0), -1);

					if (NumFree > 0)
					{
						ProbeIndex = imageLoad(ProbeFreeList, ivec2(NumFree - 1,0)).r;
					}
					else
					{
						ProbeIndex = imageAtomicAdd(ProbeAllocator, ivec2(0, 0), 1);
					}
				}
				else
				{
					ProbeIndex = imageAtomicAdd(ProbeAllocator, ivec2(0, 0), 1);
				}
				
				imageStore(ProbeLastTracedFrame, ivec2(ProbeIndex, 0), uvec4(PROBE_FRAME_INDEX_NEVER_TRACED));
				imageStore(ProbeLastUsedFrame, ivec2(ProbeIndex, 0), uvec4(FrameNumber));

				LastTracedFrameIndex = PROBE_FRAME_INDEX_NEVER_TRACED;
				LastUsedFrameIndex = FrameNumber;
			}
			else
			{
				// Re-trace existing probe
				ProbeIndex = ProbeUsedMarker;
				LastTracedFrameIndex = imageLoad(ProbeLastTracedFrame, ivec2(ProbeIndex,0)).r;
				LastUsedFrameIndex = imageLoad(ProbeLastUsedFrame, ivec2(ProbeIndex,0)).r;
			}

			if (ProbeIndex < MaxProbeCount)
			{
				// Update histogram
				const uint PriorityBucketIndex = GetPriorityBucketIndex(LastTracedFrameIndex, LastUsedFrameIndex, ProbeWorldPosition);
				uint ProbeTraceCost = GetProbeTraceCost(ProbeWorldPosition);
				imageAtomicAdd(PriorityHistogram, ivec2(PriorityBucketIndex,0), ProbeTraceCost);

				imageStore(RadianceProbeIndirectionTexture, ivec3(gl_GlobalInvocationID), uvec4(ProbeIndex));
			}
			else
			{
				imageStore(RadianceProbeIndirectionTexture, ivec3(gl_GlobalInvocationID), uvec4(INVALID_PROBE_INDEX));
			}
		}
	}
}

void main(){
	AllocateUsedProbesCS();
}
