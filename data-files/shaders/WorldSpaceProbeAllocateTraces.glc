#version 430
#extension GL_ARB_texture_query_lod : enable
#extension GL_ARB_compute_variable_group_size : enable
//#include "WorldSpaceProbe_Common.pix"

#define USED_PROBE_INDEX 0xFFFFFFFE
#define RADIANCE_PROBE_MAX_CLIPMAPS 4
#define INVALID_PROBE_INDEX 0xFFFFFFFF
#define PROBE_FRAME_INDEX_NEVER_TRACED 0
#define MAX_UPDATE_FREQUENCY 7.0f
#define FINAL_ATLAS_RESOLUSION 128*16
#define PRIORITY_HISTOGRAM_SIZE 128


layout( local_size_variable ) in;


layout(std430, binding=0) buffer radianceProbeCoordToWorldPosition {vec4 RadianceProbeCoordToWorldPosition[];};
layout(std430, binding=1) buffer maxUpdateBucket { uint MaxUpdateBucket[];};

layout(r32ui) uniform uimage3D RadianceProbeIndirectionTexture;
layout(r32ui) uniform uimage2D ProbeLastUsedFrame;
layout(r32ui) uniform uimage2D ProbeLastTracedFrame;

layout(r32ui) uniform uimage2D MaxTracesFromMaxUpdateBucket;
layout(r32ui) uniform uimage2D ProbesToUpdateTraceCost;
layout(r32ui) uniform uimage2D ProbeTraceAllocator;
layout(rgba32f) uniform image2D ProbeTraceData;


uniform uint FrameNumber;

uniform int RadianceProbeClipmapResolution;

uniform int MaxProbeCount;
uniform vec3 WorldCameraOrigin;
uniform float FirstClipmapWorldExtentRcp;
uniform int NumProbesToTraceBudget;

uniform float DownsampleDistanceFromCameraSq;
uniform float SupersampleDistanceFromCameraSq;

uint GetPriorityBucketIndex(uint LastTracedFrameIndex, uint LastUsedFrameIndex, vec3 ProbeWorldPosition)
{
	// [1;N]
	uint FramesBetweenTracedAndUsed = LastUsedFrameIndex - LastTracedFrameIndex;

	uint BucketIndex = 0;

	if (LastTracedFrameIndex == PROBE_FRAME_INDEX_NEVER_TRACED)
	{
		// Special case for probes which were created this frame. Places those in the most important bucket 0.
		BucketIndex = 0;
	}
	else
	{
		// [0;MAX_UPDATE_FREQUENCY]
		float Frequency = 1.0f;
		{
			vec3 CameraVector = WorldCameraOrigin - ProbeWorldPosition;
			const float DistanceFromViewer = sqrt(dot(CameraVector, CameraVector));
			Frequency = MAX_UPDATE_FREQUENCY - clamp(DistanceFromViewer * FirstClipmapWorldExtentRcp, 0.0f, MAX_UPDATE_FREQUENCY);
		}
		// [1;N]
		float UpdateImportance = FramesBetweenTracedAndUsed * (Frequency + 1.0f);

		// Normalize histogram based on the expected range
		float HistogramScale = (PRIORITY_HISTOGRAM_SIZE * NumProbesToTraceBudget) / (MaxProbeCount * (MAX_UPDATE_FREQUENCY + 1.0f));

		// Remap from [1;N] to log2([N;1])
		BucketIndex = uint(PRIORITY_HISTOGRAM_SIZE - 1 - clamp((UpdateImportance - 1.0f) * HistogramScale, 0, PRIORITY_HISTOGRAM_SIZE - 2));
	}

	return BucketIndex;
}


uint GetProbeTraceCost(vec3 ProbeWorldPosition)
{
	vec3 CameraVector = WorldCameraOrigin - ProbeWorldPosition;
	float DistanceFromCameraSq = dot(CameraVector, CameraVector);

	if (DistanceFromCameraSq < SupersampleDistanceFromCameraSq)
	{
		return 16;
	}

	if (DistanceFromCameraSq < DownsampleDistanceFromCameraSq)
	{
		return 4;
	}

	return 1;
}


void AllocateProbeTracesCS()
{
	uint ClipmapIndex = gl_GlobalInvocationID.x / RadianceProbeClipmapResolution;
	uvec3 ProbeCoord = uvec3(gl_GlobalInvocationID.x - ClipmapIndex * RadianceProbeClipmapResolution, gl_GlobalInvocationID.yz);

	if (ClipmapIndex < RADIANCE_PROBE_MAX_CLIPMAPS && all(lessThan(ProbeCoord, uvec3(RadianceProbeClipmapResolution))))
	{
		const uint ProbeIndex = imageLoad(RadianceProbeIndirectionTexture, ivec3(gl_GlobalInvocationID)).r;
		vec3 ProbeWorldPosition = ProbeCoord * RadianceProbeCoordToWorldPosition[ClipmapIndex].w + RadianceProbeCoordToWorldPosition[ClipmapIndex].xyz;

		if (ProbeIndex < MaxProbeCount)
		{
			uint MaxUpdateBucketIndex = MaxUpdateBucket[0];
			const uint LocalMaxTracesFromMaxUpdateBucket = imageLoad(MaxTracesFromMaxUpdateBucket, ivec2(0,0)).r;

			const uint ProbeTraceCost = GetProbeTraceCost(ProbeWorldPosition);
			const uint LastTracedFrameIndex = imageLoad(ProbeLastTracedFrame, ivec2(ProbeIndex,0)).r;
			const uint LastUsedFrameIndex = imageLoad(ProbeLastUsedFrame ,ivec2(ProbeIndex,0)).r;

			// Update everything up to the max selected priority bucket
			const uint PriorityBucketIndex = GetPriorityBucketIndex(LastTracedFrameIndex, LastUsedFrameIndex, ProbeWorldPosition);

			bool bTraceProbe = PriorityBucketIndex <= MaxUpdateBucketIndex;
			
			//imageStore(ProbeWorldOffset, ivec2(ProbeIndex %128, ProbeIndex /128), vec4(PriorityBucketIndex));
			// Can't trace more than MaxTracesFromMaxUpdateBucket from the last bucket
			// Make an exception for the first bucket, as it contains probes without valid data
			if (bTraceProbe && PriorityBucketIndex == MaxUpdateBucketIndex && MaxUpdateBucketIndex > 0)
			{
				// Accumulate allocated probe trace cost for the last bucket
				uint ProbeTraceAllocatedFromMaxUpdateBucket = 0;
				ProbeTraceAllocatedFromMaxUpdateBucket = imageAtomicAdd(ProbesToUpdateTraceCost, ivec2(1,0), ProbeTraceCost);

				if (ProbeTraceAllocatedFromMaxUpdateBucket + ProbeTraceCost > LocalMaxTracesFromMaxUpdateBucket)
				{
					bTraceProbe = false;
				}
			}
			
			if (bTraceProbe)
			{
				
				imageAtomicAdd(ProbesToUpdateTraceCost, ivec2(0, 0), ProbeTraceCost);
				uint TraceIndex = imageAtomicAdd(ProbeTraceAllocator, ivec2(0, 0), 1);
				
				imageStore(ProbeTraceData, ivec2(TraceIndex, 0), vec4(ProbeWorldPosition, uintBitsToFloat((ClipmapIndex << 24) | ProbeIndex)));
				imageStore(ProbeLastTracedFrame, ivec2(ProbeIndex, 0), uvec4(FrameNumber));
			}
		}
	}
}

void main(){
	AllocateProbeTracesCS();
}
